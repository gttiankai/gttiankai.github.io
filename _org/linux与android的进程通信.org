#+STARTUP: showall
#+STARTUP: hidestars
#+OPTIONS: H:2 num:nil tags:nil toc:nil timestamps:t
#+LAYOUT: post
#+AUTHOR: tiankai
#+DATE: 2018-11-22 四 15:07
#+TITLE: Linux与Android的进程通信
#+DESCRIPTION: Linux Android 进程间通信，Binder
#+TAGS: Android
#+CATEGORIES: Android

* 进程间通信的定义（IPC）
进程是计算机系统分配资源的最小单位(严格说来是线程)。每个进程都有自己的一部分独立
的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进
程间通信。通常，使用进程间通信的两个应用可以被分为客户端和服务器（见主从式架构），
客户端进程请求数据，服务端响应客户端的数据请求。有一些应用本身既是服务器又是客户
端，这在分布式计算中，时常可以见到。这些进程可以运行在同一计算机上或网络连接的不
同计算机上。

 以上的定义来来源于：[[https://zh.wikipedia.org/wiki/%25E8%25A1%258C%25E7%25A8%258B%25E9%2596%2593%25E9%2580%259A%25E8%25A8%258A][wiki百科]]

* Linux 系统上的进程间通信
** 管道（PIPE）
*** 管道的介绍（也叫做匿名管道）
- 管道的创建函数：
#+begin_src C
#include <unisstd.h>

int pipe(int fledes[2]);
// 返回值： 若成功则返回0，若出错则返回-1
// fledes[0]为读，fledes[1]为写
#+end_src
单个进程中的管道是没有意义的。通常的做法是，在调用 pipe 的进程中接着调用 fork，
这样就创建了父进程到子进程（或反向）的 IPC 通道。

- 管道是半双工的，数据只能向一个方向流动；如果需要双向通信时，需要建立两个管道。
- 从上面的使用中可以看出，管道只能用于父子进程或者兄弟进程之间进行通信，也就是说
  管道只能用于具有情缘关系的进程间进行通信。
- 数据的读出和写入：一个进程向管道中写的内容被管道的另一端的进程读出。写入的内容
  每次都添加在管道缓冲区的尾部，并且每次都是从缓冲区的头部读出数据。
*** 管道的实质
管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程
顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。该缓冲区可以看做是一个循环
队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后
在缓冲区就不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写
进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等
待队列中的进程继续读写。
*** 管道的局限性 
- 只支持单向数据结构
- 只能用于具有亲缘关系的进程之间
- 没有名字
- 管道的缓冲区是有限的（管道存在于内存中，在管道创时，为缓冲区分配一个页面大小）
- 管道所传送的是无格式字节流，所以管道的读出方和写入方必须实现约定好数据的格式，
  这样才能进行通信。

** 命名管道（FIFO）
*** 命名管道介绍
- 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了客户这个缺点，提出了
  命名管道（FIFO）。命名管道提供了路径名与之关联，以命名管道的文件形式存在于文件
  系统中，这样，即使与命名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，
  就能够彼此通过有名管道项目通信。
  命名管道的实现代码：
  #+begin_src C
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);

//返回值：若成功则返回0，若出错则返回-1
  #+end_src
- 命名管道严格遵循先进先出（FIFO） 原则，对命名管道的读总是从开始处进行返回数据，
  对他们的写操作把数据添加到末尾，不支持 lseek() 等文件定位操作。命名管道的名字
  存在于文件系统中，内容存放在内存中。

** 信号（signal）
- 信号是 Linux 系统中用于进程间相互通信或者操作的一种机制，信号可以在任何时候发
  给某一进程，而无需知道该进程的状态。
- 如果该进程当前未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传
  递给它为止。
-  如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消才被传递
  给进程。
** 消息队列（message）
** 共享内存（shared memory）
- 共享内存就是允许两个不相关的进程访问同一个逻辑内存，共享内存是在两个正在运行的
  进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同
  一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可
  以访问共享内存中的地址，就好像它们是由用 C 语言函数 malloc 分配的内存一样。而
  如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的
  任何其他进程。
- 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同
  步及互斥。

** 信号量
- 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。为
  了获得共享资源，进程需要执行下列的操作：
  1. 创建信号量：要求调用者指定初始值，对于二值信号量来说，他通常是1，也可以是0。
  2. 等待信号量：该操作会测试这个信号量的值，如果小于0，则堵塞。也成为 P 操作。
  3. 挂出信号量：该操作将信号量的值加1，也成为 V 操作。
- 为了正确的实现信号量，信号量的值的测试及减1操作应当是原子操作。所以信号量通常
  在内核中实现的。

*** 套接字（socket）
- 套接字是一种通信机制，凭借这种机制，客户/服务器系统的开发工作既可以在本地单机
  上运行，也可以跨网络运行。也就是说他可以在不在同一台计算机但通过网络连接计算机
  的进程进行通信。
